{
    "collab_server" : "",
    "contents" : "\nsplit_dataset<-function(data, prozent_train){\n  #set.seed(101) # Set Seed so that same sample can be reproduced in future also\n  # Now Selecting 75% of data as sample from total 'n' rows of the data  \n  sample <- sample.int(n = nrow(data), size = floor(prozent_train*nrow(data)), replace = F)\n  train <- data[sample, ]\n  test  <- data[-sample, ]\n  train_test=list(\"train\"=train, \"test\"=test)\n  return(train_test)\n}\n\n\n#'vtreat' prepares variables so that data has \n#fewer exceptional cases, making it easier to safely \n#use models in production. Common problems 'vtreat' defends against: 'Inf', 'NA', \n#too many categorical levels, rare categorical levels, and new categorical levels \n#(levels seen during application, but not during training). 'vtreat::prepare' should be used as you would use 'model.matrix'.\n\nvtreat_vars = function(data){\n  #EXAMPLE:\n  #library(vtreat)\n  #label = data.table.full$is_listened\n  #dframe_treat = vtreat_vars(data.table.full[,-\"is_listened\"])\n  #dframe_treat$is_listened=label\n  \n  features = colnames(data)\n  #target_var = data[,vars_to_save]\n  \n  treatplan <- designTreatmentsZ(data, features)\n  #data.treat <- prepare(treatplan, data)\n  # Examine the scoreFrame\n  scoreFrame <- treatplan$scoreFrame %>% select(varName, origName, code)\n  # We only want the rows with codes \"clean\" or \"lev\"\n  newvars <- (scoreFrame %>% filter(code %in% c(\"clean\", \"lev\")))$varName\n  # Create the treated training data\n  dframe.treat <- prepare(treatplan, data, varRestriction = newvars)\n  str(dframe.treat)\n  \n  #dframe.treat[,vars_to_save]=target_var\n  \n  return(dframe.treat)\n}\n\n#compute smoothed mean of the targetvariable per defined group and stoes it in new variables, smoothed to avoid overfiting.\n#var_groups is list(c ( ,), c( , ) ...)\n# target values of the test set should be set to \"NA\". \n\nsmoothed_mean_per_group <- function(data_in, target_name, var_groups, alpha){\n  #data_in = data.table(data)\n  \n  global_target_mean=mean( data_in[!(is.na(get(target_name))), get(target_name), ])\n  \n  \n  for (group in var_groups){\n    group_in = unlist(group)\n    if(length(group_in)==2){    \n      \n      a =group_in[1]\n      b = group_in[2]\n      print(\"Group:\")\n      print(a)\n      print(b)\n      new_var_name = paste(a,b, sep = \"_\")\n      \n      data_in[!(is.na((get(target_name)))), eval(new_var_name) := ((mean((get(target_name)))*.N)+(global_target_mean*alpha))/(.N+alpha), by=c(eval(a), eval(b))]\n      data_in[is.na(get(target_name)), eval(new_var_name):=0]\n      data_in[, eval(new_var_name) := max(get(new_var_name)), by=c(eval(a), eval(b))]\n    } else if(length(group_in)==3){  \n      print(\"Group:\")\n      a =group_in[1]\n      b = group_in[2]\n      c = group_in[3]\n      print(a)\n      print(b)\n      new_var_name = paste(a,b,c, sep = \"_\")\n      \n      data_in[!(is.na((get(target_name)))), eval(new_var_name) := ((mean((get(target_name)))*.N)+(global_target_mean*alpha))/(.N+alpha), by=c(eval(a), eval(b), eval(c))]\n      data_in[is.na(get(target_name)), eval(new_var_name):=0]\n      data_in[, eval(new_var_name) := max(get(new_var_name)), by=c(eval(a), eval(b), eval(c))]\n      \n    } else\n    {\n      print(\"Only works for 2 or 3 combinations\")\n    }\n    \n    \n    \n  }\n  return(data_in)\n  \n}\n\n\nsmoothed_mean_per_group_by_pos <- function(data_in, target_name, var_groups, alpha){\n  #data_in = data.table(data)\n  \n  global_target_mean=mean( data_in[!(is.na(get(target_name))), get(target_name), ])\n  \n  \n  for (group in var_groups){\n    group_in = unlist(group)\n    if(length(group_in)==2){  \n      \n      a =group_in[1]\n      b = group_in[2]\n      print(\"Group:\")\n      print(a)\n      print(b)\n      new_var_name = paste(a,b, \"_by_pos\", sep = \"_\")\n      \n      data_in[!(is.na((get(target_name)))), eval(new_var_name) := (mean((get(target_name)))+(global_target_mean*alpha))/(sum(get(target_name))+alpha), by=c(eval(a), eval(b))]\n      data_in[is.na(get(target_name)), eval(new_var_name):=0]\n      data_in[, eval(new_var_name) := max(get(new_var_name)), by=c(eval(a), eval(b))]\n    } else if (length(group_in)==3)\n    {\n      print(\"Group:\")\n      a =group_in[1]\n      b = group_in[2]\n      c = group_in[3]\n      print(a)\n      print(b)\n      new_var_name = paste(a,b,c, \"_by_pos\", sep = \"_\")\n      \n      data_in[!(is.na((get(target_name)))), eval(new_var_name) := (mean((get(target_name)))+(global_target_mean*alpha))/(sum(get(target_name))+alpha), by=c(eval(a), eval(b), eval(c))]\n      data_in[is.na(get(target_name)), eval(new_var_name):=0]\n      data_in[, eval(new_var_name) := max(get(new_var_name)), by=c(eval(a), eval(b), eval(c))]\n      \n    } else\n    {\n      print(\"Only works for 2 or 3 combinations\")\n    }\n    \n    \n  }\n  return(data_in)\n  \n}\n\n#calculate moments of a fature (that correlates with target) pe defined groups\nmoments_per_group_on_real_corelated_var <- function(data_in, corelated_real_var, var_groups){\n  #data_in = data.table(data)\n  \n  for (group in var_groups){\n    group_in = unlist(group)\n    if(length(group_in)==2){  \n      \n      a =group_in[1]\n      b = group_in[2]\n      print(\"Group:\")\n      print(a)\n      print(b)\n      mean = paste(a,b,corelated_real_var, \"_mean\", sep = \"_\")\n      #median = paste(a,b,corelated_real_var, \"median\", sep = \"_\")\n      min = paste(a,b,corelated_real_var, \"_min\", sep = \"_\")\n      lower = paste(a,b,corelated_real_var, \"_lower\", sep = \"_\")\n      middle = paste(a,b,corelated_real_var, \"_middle\", sep = \"_\")\n      upper = paste(a,b,corelated_real_var, \"_upper\", sep = \"_\")\n      max = paste(a,b,corelated_real_var, \"_max\", sep = \"_\")\n      \n      data_in[, c(mean,min,lower, middle,upper,max ):= list(\n        mean(get(corelated_real_var)),\n        min(get(corelated_real_var)),\n        quantile(get(corelated_real_var), .25, na.rm=TRUE),\n        quantile(get(corelated_real_var), .50, na.rm=TRUE),\n        quantile(get(corelated_real_var), .75, na.rm=TRUE),\n        max(get(corelated_real_var))),\n        by=c(eval(a), eval(b))]\n      \n      \n      \n    } else if (length(group_in)==3)\n    {\n      print(\"Group:\")\n      a =group_in[1]\n      b = group_in[2]\n      c = group_in[3]\n      \n      print(\"Group:\")\n      print(a)\n      print(b)\n      print(c)\n      mean = paste(a,b,corelated_real_var, \"_mean\", sep = \"_\")\n      #median = paste(a,b,corelated_real_var, \"median\", sep = \"_\")\n      min = paste(a,b,corelated_real_var, \"_min\", sep = \"_\")\n      middle = paste(a,b,corelated_real_var, \"_middle\", sep = \"_\")\n      upped = paste(a,b,corelated_real_var, \"_upper\", sep = \"_\")\n      max = paste(a,b,corelated_real_var, \"_max\", sep = \"_\")\n      \n      data_in[,c(mean,min,middle,upper,max ):= list(\n        \n        mean(get(corelated_real_var)),\n        min(get(corelated_real_var)),\n        quantile(get(corelated_real_var), .25, na.rm=TRUE),\n        quantile(get(corelated_real_var), .50, na.rm=TRUE),\n        quantile(get(corelated_real_var), .75, na.rm=TRUE),\n        max(get(corelated_real_var))),\n        \n        by=c(eval(a), eval(b), eval(c))]\n      \n      \n    } else\n    {\n      print(\"Only works for 2 or 3 combinations\")\n    }\n    \n    \n  }\n  return(data_in)\n  \n}\n\n\n\n\n\n\n\n",
    "created" : 1506365959713.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1784856529",
    "id" : "3C232732",
    "lastKnownWriteTime" : 1506366901,
    "last_content_update" : 1506366901497,
    "path" : "~/Documents/HU_Berlin/ML/DSG/DSG_2017_Finals/functions/vtreat_smothed_mean.R",
    "project_path" : "functions/vtreat_smothed_mean.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}